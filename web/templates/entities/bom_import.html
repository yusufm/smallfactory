{% extends 'base.html' %}

{% block title %}Import BOM Â· {{ entity.sfid }}{% endblock %}

{% block content %}
<div class="max-w-5xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
  <div class="flex items-center justify-between mb-4">
    <div>
      <div class="text-sm text-gray-500"><a class="text-blue-600 hover:underline" href="{{ url_for('entities_view', sfid=entity.sfid) }}">{{ entity.sfid }}</a></div>
      <h1 class="text-2xl font-semibold text-gray-900">Import BOM from CSV</h1>
      <div class="text-gray-700">{{ entity.name or entity.sfid }}</div>
    </div>
    <div class="flex items-center gap-2">
      <a href="{{ url_for('entities_view', sfid=entity.sfid) }}" class="px-3 py-1.5 rounded border border-gray-300 bg-white text-gray-700 hover:bg-gray-50"><i class="fas fa-arrow-left mr-2"></i>Back to Entity</a>
    </div>
  </div>

  <div class="bg-white shadow rounded-lg">
    <div class="px-5 py-3 border-b border-gray-200">
      <div class="text-sm text-gray-600">
        Upload a CSV file or paste CSV text. Columns supported: <span class="font-mono">qty</span>, <span class="font-mono">rev</span>, <span class="font-mono">manufacturer</span>, <span class="font-mono">mpn</span>, and optional <span class="font-mono">use</span>.
        If <span class="font-mono">use</span> is omitted, a unique <span class="font-mono">manufacturer+mpn</span> match will be auto-filled. Ambiguous matches are flagged and skipped.
      </div>
    </div>
    <div class="p-5 space-y-4">
      <div class="grid md:grid-cols-2 gap-4">
        <div>
          <label class="block text-xs font-medium text-gray-700 mb-1">CSV file</label>
          <input id="imp-file" type="file" accept=".csv,text/csv" class="w-full text-sm" />
        </div>
        <div>
          <label class="block text-xs font-medium text-gray-700 mb-1">Or paste CSV text</label>
          <textarea id="imp-text" rows="6" class="w-full border border-gray-300 rounded px-3 py-2 focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500" placeholder="qty,rev,manufacturer,mpn\n1,released,ACME,AC-456"></textarea>
        </div>
      </div>
      <div id="imp-error" class="text-sm text-red-600"></div>
      <div id="imp-summary" class="text-sm text-gray-600"></div>
      <div class="border border-gray-200 rounded overflow-hidden">
        <table class="min-w-full text-sm">
          <thead class="bg-gray-50 text-gray-700">
            <tr>
              <th class="px-2 py-1 text-left">Use</th>
              <th class="px-2 py-1 text-left">Name</th>
              <th class="px-2 py-1 text-right">Qty</th>
              <th class="px-2 py-1 text-left">Rev</th>
              <th class="px-2 py-1 text-left">Manufacturer</th>
              <th class="px-2 py-1 text-left">MPN</th>
              <th class="px-2 py-1 text-left">Status</th>
            </tr>
          </thead>
          <tbody id="imp-preview-tbody" class="divide-y divide-gray-100"></tbody>
        </table>
      </div>
      <div class="flex justify-end gap-2">
        <button id="imp-reset" type="button" class="px-3 py-1.5 rounded border border-gray-300 bg-white text-gray-700 hover:bg-gray-50">Reset</button>
        <button id="imp-preview" type="button" class="px-3 py-1.5 rounded bg-gray-700 text-white hover:bg-gray-800">Preview</button>
        <button id="imp-apply" type="button" class="px-3 py-1.5 rounded bg-green-600 text-white hover:bg-green-700 disabled:opacity-50" disabled>Apply</button>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
(function(){
  const SFID = '{{ entity.sfid }}';
  let previewRows = [];
  let existingUses = new Set();
  let existingRows = [];

  const elFile = () => document.getElementById('imp-file');
  const elText = () => document.getElementById('imp-text');
  const elErr = () => document.getElementById('imp-error');
  const elSum = () => document.getElementById('imp-summary');
  const elTBody = () => document.getElementById('imp-preview-tbody');
  const elApply = () => document.getElementById('imp-apply');

  // SFID helpers (matches SPECIFICATION.md authoritative regex)
  const SFID_REGEX = /^(?=.{3,64}$)[a-z]+_[a-z0-9_-]*[a-z0-9]$/;
  const isValidSfid = (s) => {
    const v = String(s||'').trim();
    return SFID_REGEX.test(v);
  };
  const normalizeSfid = (s) => String(s||'').trim().toLowerCase();

  // Suggestion helpers
  const slugToken = (s) => {
    let t = String(s||'').toLowerCase().trim();
    if(!t) return '';
    // replace non [a-z0-9_-] with '-'
    t = t.replace(/[^a-z0-9_-]+/g, '-');
    // collapse repeats
    t = t.replace(/-{2,}/g, '-').replace(/_{2,}/g, '_');
    // trim leading/trailing separators
    t = t.replace(/^[-_]+/, '').replace(/[-_]+$/, '');
    // ensure last char alnum
    if(t && !/[a-z0-9]$/.test(t)) t = t.replace(/[-_]+$/, '');
    if(t && !/[a-z0-9]$/.test(t)) t += '0';
    return t;
  };
  const clampLen = (s, max) => (s.length <= max ? s : s.slice(0, max));
  function suggestSfidForRow(row, taken){
    // Build base from mpn (preferred), else manufacturer+mpn, else name
    const mfr = (row.manufacturer||row.mfr||'').toString();
    const mpn = (row.mpn||row.mfr_pn||'').toString();
    const name = (row.name||'').toString();
    let token = slugToken(mpn) || (slugToken(mfr) && slugToken(mpn) ? `${slugToken(mfr)}-${slugToken(mpn)}` : '') || slugToken(name);
    if(!token) return '';
    // Respect overall length <= 64; prefix 'p_'
    token = clampLen(token, 62); // leaves space for 'p_'
    let candidate = `p_${token}`;
    // Ensure validity and uniqueness
    if(!isValidSfid(candidate)){
      // Fallback: ensure prefix and alnum end
      candidate = candidate.replace(/[^a-z0-9_-]/g, '-');
      candidate = candidate.replace(/-{2,}/g, '-');
      candidate = candidate.replace(/[-_]+$/, '');
      if(!/[a-z0-9]$/.test(candidate)) candidate += '0';
      // Final clamp
      if(candidate.length > 64) candidate = candidate.slice(0, 64);
    }
    // Do not add numeric suffixes for uniqueness; if it already exists, use it as-is
    if(!isValidSfid(candidate)) return '';
    return candidate;
  }

  function updateSummaryAndApplyButton(){
    if(!Array.isArray(previewRows)) previewRows = [];
    const csvUses = new Set(previewRows.filter(r => !r.ambiguous).map(r => normalizeSfid(r.use)).filter(Boolean));
    const removalCandidates = (existingRows||[]).filter(r => !csvUses.has(normalizeSfid(r.use)));
    const n = previewRows.length;
    if(elSum()) elSum().textContent = `${n} row${n===1?'':'s'} in preview. ${removalCandidates.length} existing line${removalCandidates.length===1?'':'s'} will be removed.`;
    const hasActions = (csvUses.size > 0) || (removalCandidates.length > 0);
    if(elApply()) elApply().disabled = !hasActions;
  }

  async function loadExistingUses(){
    try{
      const res = await fetch(`/api/entities/${encodeURIComponent(SFID)}/bom`);
      const data = await res.json();
      const rows = Array.isArray(data.rows) ? data.rows : [];
      existingRows = rows;
      existingUses = new Set(rows.map(r => String(r.use||'').trim()).filter(Boolean));
    }catch(e){ /* non-fatal */ }
    // Keep summary/apply state in sync after rendering
    updateSummaryAndApplyButton();
  }

  function resetAll(){
    previewRows = [];
    if(elFile()) elFile().value = '';
    if(elText()) elText().value = '';
    if(elTBody()) elTBody().innerHTML = '';
    if(elErr()) elErr().textContent = '';
    if(elSum()) elSum().textContent = '';
    if(elApply()) elApply().disabled = true;
  }

  function onFileChange(){
    if(elFile() && elFile().files && elFile().files.length > 0 && elText()) elText().value = '';
  }
  function onTextInput(){
    if(elText() && elText().value.trim() && elFile()) elFile().value = '';
  }

  async function runPreview(){
    if(elErr()) elErr().textContent = '';
    if(elSum()) elSum().textContent = '';
    if(elTBody()) elTBody().innerHTML = '';
    if(elApply()) elApply().disabled = true;

    const f = elFile();
    const t = elText();
    const hasFile = !!(f && f.files && f.files.length > 0);
    const text = (t && t.value || '').trim();
    if(!hasFile && !text){ if(elErr()) elErr().textContent = 'Please choose a CSV file or paste CSV text.'; return; }

    try{
      // Ensure we have the latest existing BOM before diffing
      await loadExistingUses();
      const form = new FormData();
      if(hasFile){ form.append('file', f.files[0]); }
      else{ form.append('csv_text', text); }
      const res = await fetch(`/api/entities/${encodeURIComponent(SFID)}/bom/import/preview`, { method:'POST', body: form });
      const data = await res.json();
      if(!data.success) throw new Error(data.error || 'Preview failed');
      previewRows = Array.isArray(data.rows) ? data.rows : [];
      renderPreview(previewRows);
      const n = previewRows.length;
      // Compute removals summary
      const csvUses = new Set(previewRows.filter(r => !r.ambiguous).map(r => String(r.use||'').trim()).filter(Boolean));
      const removalCandidates = (existingRows||[]).filter(r => !csvUses.has(String(r.use||'').trim()));
      if(elSum()) elSum().textContent = `${n} row${n===1?'':'s'} in preview. ${removalCandidates.length} existing line${removalCandidates.length===1?'':'s'} will be removed.`;
      // Enable Apply if there will be any changes (adds/updates OR removals)
      const hasActions = (csvUses.size > 0) || (removalCandidates.length > 0);
      if(elApply()) elApply().disabled = !hasActions;
    }catch(e){ if(elErr()) elErr().textContent = e.message || String(e); }
  }

  function canApplyRow(r){
    const use = normalizeSfid(r.use);
    if(r.ambiguous) return false;
    if(!use) return false;
    if(!isValidSfid(use)) return false;
    if(existingUses.has(use)) return false;
    return true;
  }

  function renderPreview(rows){
    const tb = elTBody(); if(!tb) return;
    tb.innerHTML = '';
    // Compute suggestions for rows missing use, ensuring no collisions with existing or within-preview
    const taken = new Set(Array.from(existingUses || []));
    rows.forEach((r) => {
      const use = normalizeSfid(r.use);
      if((!use || !isValidSfid(use)) && !r.ambiguous){
        const sug = suggestSfidForRow(r, taken);
        if(sug){ r.use = sug; r.auto_suggested = true; }
      }
      if(r.use) taken.add(normalizeSfid(r.use));
    });
    // 1) Render CSV-derived rows
    rows.forEach((r, i) => {
      const use = normalizeSfid(r.use);
      const name = (r.name||'').trim();
      const qty = r.qty ?? 1;
      const rev = (r.rev||'released');
      const mfr = r.manufacturer||'';
      const mpn = r.mpn||'';
      let status = '';
      let badge = '';
      let rowCls = '';
      let canApply = canApplyRow(r);
      const showInput = r.ambiguous || (!use || !isValidSfid(use)) || (!!r.auto_suggested);
      if(r.ambiguous){
        status = 'Ambiguous';
        badge = '<span class="px-2 py-0.5 rounded text-xs bg-yellow-100 text-yellow-800">ambiguous</span>';
        rowCls = 'bg-yellow-50';
      }else if(!use){
        status = 'Missing SFID';
        badge = '<span class="px-2 py-0.5 rounded text-xs bg-red-100 text-red-700">missing</span>';
        rowCls = 'bg-red-50';
      }else if(!isValidSfid(use)){
        status = 'Invalid SFID';
        badge = '<span class="px-2 py-0.5 rounded text-xs bg-red-100 text-red-700">invalid</span>';
        rowCls = 'bg-red-50';
      }else if(existingUses.has(use)){
        status = 'Already present';
        badge = '<span class="px-2 py-0.5 rounded text-xs bg-gray-200 text-gray-700">exists</span>';
        rowCls = 'opacity-70';
      }else if(r.auto_suggested){
        status = 'Suggested';
        badge = '<span class="px-2 py-0.5 rounded text-xs bg-indigo-100 text-indigo-700">suggested</span>';
      }else if(r.auto_filled){
        status = 'Auto-filled';
        badge = '<span class="px-2 py-0.5 rounded text-xs bg-green-100 text-green-700">auto</span>';
        rowCls = '';
      }else{
        status = 'OK';
        badge = '<span class="px-2 py-0.5 rounded text-xs bg-blue-100 text-blue-700">ok</span>';
      }
      const useCell = showInput
        ? `<input data-sfid-input="1" data-row-index="${i}" type="text" value="${use||''}"
                 placeholder="p_example"
                 class="w-44 border ${isValidSfid(use)?'border-gray-300':'border-red-300'} rounded px-2 py-1 font-mono text-sm" />`
        : `<span class="font-mono text-blue-700">${use||'â'}</span>`;
      tb.insertAdjacentHTML('beforeend', `
        <tr class="${rowCls}" data-can-apply="${canApply?'1':'0'}">
          <td class="px-2 py-1">${useCell}</td>
          <td class="px-2 py-1">${name||'â'}</td>
          <td class="px-2 py-1 text-right">${qty}</td>
          <td class="px-2 py-1">${rev||'released'}</td>
          <td class="px-2 py-1">${mfr||'â'}</td>
          <td class="px-2 py-1">${mpn||'â'}</td>
          <td class="px-2 py-1">${badge} <span class="text-gray-600">${status}</span></td>
        </tr>
      `);
    });

    // 2) Render removal candidates from existing BOM that are not present in CSV
    const csvUses = new Set(rows.filter(rr => !rr.ambiguous).map(rr => String(rr.use||'').trim()).filter(Boolean));
    const toRemove = (existingRows||[]).filter(er => !csvUses.has(String(er.use||'').trim()));
    if(toRemove.length){
      tb.insertAdjacentHTML('beforeend', `
        <tr class="bg-red-100">
          <td class="px-2 py-1 text-xs text-red-800" colspan="7">Removals</td>
        </tr>
      `);
    }
    toRemove.forEach(er => {
      const use = (er.use||'').trim();
      const name = (er.name||'').trim();
      const qty = er.qty ?? 1;
      const rev = (er.rev||'released');
      const badge = '<span class="px-2 py-0.5 rounded text-xs bg-red-100 text-red-700">remove</span>';
      tb.insertAdjacentHTML('beforeend', `
        <tr class="bg-red-50" data-remove="1">
          <td class="px-2 py-1 font-mono text-red-700">${use||'â'}</td>
          <td class="px-2 py-1">${name||'â'}</td>
          <td class="px-2 py-1 text-right">${qty}</td>
          <td class="px-2 py-1">${rev||'released'}</td>
          <td class="px-2 py-1">â</td>
          <td class="px-2 py-1">â</td>
          <td class="px-2 py-1">${badge} <span class="text-gray-700">Will remove</span></td>
        </tr>
      `);
    });
  }

  function onTBodyInput(ev){
    const t = ev.target;
    if(!(t && t.matches('input[data-sfid-input="1"]'))) return;
    const idxStr = t.getAttribute('data-row-index')||'-1';
    const idx = parseInt(idxStr, 10);
    if(Number.isNaN(idx) || idx < 0 || idx >= previewRows.length) return;
    const val = normalizeSfid(t.value);
    // reflect normalization in the UI so user sees final value
    if(t.value !== val) t.value = val;
    previewRows[idx].use = val;
    // If the user edits the suggested value, it's no longer auto-suggested
    if(previewRows[idx].auto_suggested) previewRows[idx].auto_suggested = false;
    previewRows[idx].ambiguous = false;
    // Live validate and update row UI without re-rendering entire table
    // Input border style
    t.classList.remove('border-red-300','border-gray-300');
    t.classList.add(isValidSfid(val) ? 'border-gray-300' : 'border-red-300');

    // Row-level status and class updates
    const tr = t.closest('tr');
    if(tr){
      let status = '';
      let badge = '';
      let rowCls = '';
      const duplicate = !!existingUses && existingUses.has(val);
      if(!val){
        status = 'Missing SFID';
        badge = '<span class="px-2 py-0.5 rounded text-xs bg-red-100 text-red-700">missing</span>';
        rowCls = 'bg-red-50';
      }else if(!isValidSfid(val)){
        status = 'Invalid SFID';
        badge = '<span class="px-2 py-0.5 rounded text-xs bg-red-100 text-red-700">invalid</span>';
        rowCls = 'bg-red-50';
      }else if(duplicate){
        status = 'Already present';
        badge = '<span class="px-2 py-0.5 rounded text-xs bg-gray-200 text-gray-700">exists</span>';
        rowCls = 'opacity-70';
      }else{
        status = 'OK';
        badge = '<span class="px-2 py-0.5 rounded text-xs bg-blue-100 text-blue-700">ok</span>';
        rowCls = '';
      }
      tr.className = rowCls;
      tr.setAttribute('data-can-apply', canApplyRow(previewRows[idx]) ? '1' : '0');
      const tds = tr.querySelectorAll('td');
      if(tds && tds.length >= 7){
        const statusTd = tds[6];
        statusTd.innerHTML = `${badge} <span class="text-gray-600">${status}</span>`;
      }
    }
    updateSummaryAndApplyButton();
  }

  async function applyImport(){
    if(elErr()) elErr().textContent = '';
    if(elSum()) elSum().textContent = '';
    // Allow zero preview rows (means remove all existing when remove_missing=true)
    if(!Array.isArray(previewRows)) previewRows = [];
    const btn = elApply(); if(btn) { btn.disabled = true; btn.textContent = 'Applyingâ¦'; }
    try{
      const res = await fetch(`/api/entities/${encodeURIComponent(SFID)}/bom/import/apply`, {
        method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ rows: previewRows, remove_missing: true, update_existing: true })
      });
      const data = await res.json();
      if(!res.ok || !data.success) throw new Error(data.error||'Failed to apply');
      const summary = data.summary || { added:0, updated:0, removed:0 };
      await loadExistingUses();
      await runPreview();
      if(elSum()){ elSum().textContent = `Applied. Added ${summary.added||0}, updated ${summary.updated||0}, removed ${summary.removed||0}.`; }
    }catch(e){
      if(elErr()) elErr().textContent = e.message || String(e);
    }finally{
      if(btn) { btn.disabled = false; btn.textContent = 'Apply'; }
    }
  }

  // Wire up events
  document.getElementById('imp-file').addEventListener('change', onFileChange);
  document.getElementById('imp-text').addEventListener('input', onTextInput);
  document.getElementById('imp-reset').addEventListener('click', resetAll);
  document.getElementById('imp-preview').addEventListener('click', runPreview);
  document.getElementById('imp-apply').addEventListener('click', applyImport);
  elTBody().addEventListener('input', onTBodyInput);

  // Init
  loadExistingUses();
})();
</script>
{% endblock %}
